package com.razie.pub.assets

import com.razie.pub.base._
import com.razie.pub.assets._
import scala.collection._
import com.razie.pub.data._

/** got only abstract methods so it turns into a java interface... */
trait AssetMgrTrait {
  
  type fun = (AssetKey, Referenceable, String, ScriptContext) => AnyRef

  private[this] implicit def str2ActionI (s:String) : ActionItem = new ActionItem (s)
  
  val injectedActions = new TripleIdx[String,ActionItem,AssetCmdInjector]
  val injectedFun = new TripleIdx[String,ActionItem,fun]

    
  /** classic Java type injection: create subclass with definition */
  def inject (injected:AssetCmdInjector) : Unit = {
    for (meta <- injected.entityTypes; action <- injected.actions) 
      injectedActions.put(meta, action, injected)
  }
  
  /** new type inject */
  def inject (meta:String, action:ActionItem, injected:fun) : Unit = {
      injectedFun.put(meta, action, injected)
  }

  /** */
  def injection (t:String, cmd:String) : Option[fun] = {
    injectedActions.get2 (t,cmd)
	if (injectedActions.contains(t) && injectedActions.get(t).get.contains(cmd))
         injectedActions.get(t).get.get(cmd).get.doAction
    else if (injectedFun.contains(t) && injectedFun.get(t).get.contains(cmd))
         injectedFun.get(t).get.get(cmd).get
    else 
         null
  }
  
  def injections (t:String) : Array[ActionItem] = {
    //var ret : Array[String] = Array()
    var ret : List[ActionItem] = List()
    
	if (injectedActions.contains(t)) 
	  ret = ret ++ injectedActions.get(t).get.keySet
    
    if (injectedFun.contains(t))
	  ret = ret ++ injectedFun.get(t).get.keySet
    
    ret.reverse.toArray
  }
}
